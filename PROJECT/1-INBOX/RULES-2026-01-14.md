# Strict Critical Issues: Scanner + AI Triage Tiers

**Created:** 2026-01-14
**Updated:** 2026-01-14
**Status:** In Progress
**Priority:** High

---

## Tier 1: Zero-Tolerance (Scanner-Catchable, Always Wrong)

These patterns are reliably detectable via regex and are **almost never legitimate** in WordPress/PHP code. When found, the build should fail with no baseline exceptions.

- [x] ### 1. `eval()` with any variable (PHP)

```php
// CRITICAL - Almost always malware or vulnerability
eval($code);
eval($_POST['data']);
eval(base64_decode($string));
```

**Why always critical:** Legitimate `eval()` in WordPress is extremely rare. Dynamic code execution is the hallmark of malware and backdoors.

**False positive rate:** Very low (<5%)

**Current coverage:**
- Node.js: `njs-001-eval-injection` (pattern JSON + direct pattern runner)
- PHP: `php-eval-injection` (new Tier 1 rule, implemented in `check-performance.sh` v1.3.7)

**Status:** Implemented in scanner (Node.js + PHP) as of v1.3.7.

---

- [x] ### 2. Dynamic `include`/`require` with variables

```php
// CRITICAL - Local/Remote File Inclusion → RCE
include($_GET['page'] . '.php');
require($template);
include_once($user_controlled_path);
```

**Why always critical:** File inclusion with user input leads directly to remote code execution. Even with sanitization, this pattern is dangerous.

**False positive rate:** Low (~10%). Some template loaders do this safely, but they should use whitelists.

**Current coverage:**
- PHP: `php-dynamic-include` (new Tier 1 rule, implemented in `check-performance.sh` v1.3.7)

**Status:** Implemented in scanner (PHP) as of v1.3.7.

---

- [ ] ### 3. `shell_exec`/`exec`/`system`/`passthru` (any usage)

```php
// CRITICAL - Command execution
shell_exec($cmd);
exec("convert " . $filename);
system($_GET['cmd']);
passthru($user_input);
```

**Why always critical:** Command execution in a web context is high-risk. Even "safe" uses (image processing, etc.) should be reviewed for injection vectors.

**False positive rate:** Medium (~20%). Legitimate uses exist but are rare in WordPress themes/plugins.

**Current coverage:** Node.js only (`njs-002-command-injection`). PHP not covered.

---

- [ ] ### 4. Direct file write with user-controlled path

```php
// CRITICAL - Arbitrary file write → RCE
file_put_contents($_GET['file'], $content);
move_uploaded_file($tmp_name, $user_path);
fwrite($handle, $data);  // when $handle from user input
```

**Why always critical:** Arbitrary file write allows attackers to create PHP backdoors anywhere in the filesystem.

**False positive rate:** Low (~10%). The pattern of user input → file path is specific.

**Current coverage:** Not covered.

---

- [ ] ### 5. Hardcoded credentials in PHP

```php
// CRITICAL - Exposed secrets
$api_key = 'sk_live_abc123def456';
define('API_SECRET', 'hardcoded_value');
$password = 'admin123';
'Authorization' => 'Bearer sk_live_...'
```

**Why always critical:** Credentials in code get committed to repos, leaked in error messages, and exposed in backups.

**False positive rate:** Medium (~25%). Example code and tests may trigger this, but the risk of missing a real exposure is too high.

**Current coverage:** Client-side JS only (`headless-api-key-exposure`). PHP not covered.

---

### Additional proposed Tier 1 patterns (PHP)

These are also effectively zero-tolerance in modern WordPress/PHP code and should be implemented as dedicated scanner rules:

- `create_function()` (deprecated eval-equivalent, strong malware/legacy indicator)
- `unserialize()` with user-controlled data (object injection → RCE)
- `preg_replace()` with the `/e` modifier (deprecated code execution)
- `assert()` with string arguments (code execution in older PHP configs)

Each of these will get:
- A dedicated pattern JSON definition (id, severity, rationale, remediation)
- Shell/grep-based detection in the scanner
- Tests/fixtures to keep false positives low while preserving strictness

---

- [ ] ## Tier 2: AI-Assisted Review (Scanner Flags, Context Required)

These patterns are detectable by the scanner but **require contextual analysis** to determine if they're actual issues. The scanner should flag them, but classification as Confirmed/False Positive needs AI or human review.

- [ ] ### 1. Unbounded query arguments passed indirectly

```php
// FLAGGED - Needs context
$args = array(
    'post_type' => 'product',
    'limit' => -1,  // ← Scanner can find this
);
$results = wc_get_products($args);  // ← But needs to trace $args
```

**Why AI required:**
- Is `-1` intentional for admin-only export?
- Is there pagination/chunking elsewhere?
- Is this a cron job with acceptable memory?

**Scanner's role:** Flag the `limit => -1` pattern.
**AI's role:** Read surrounding code, check for pagination, assess context.

---

- [ ] ### 2. Superglobals with partial sanitization

```php
// FLAGGED - Needs context
$id = $_GET['id'];  // ← Scanner flags this
$safe_id = absint($id);  // ← But sanitization exists nearby

// vs.

$data = $_POST['data'];  // ← Scanner flags this
echo $data;  // ← Actually dangerous - no sanitization
```

**Why AI required:**
- Is sanitization applied before use?
- Is the sanitization function appropriate for the context?
- Are there multiple code paths, some safe and some not?

**Scanner's role:** Flag all superglobal access.
**AI's role:** Trace data flow, verify sanitization is applied correctly.

---

- [ ] ### 3. Nonce checks present but potentially bypassable

```php
// FLAGGED - Needs context
if (isset($_POST['action'])) {
    wp_verify_nonce($_POST['nonce'], 'my_action');  // ← Check exists
    // But is the return value checked?
    update_option('setting', $_POST['value']);  // ← Still dangerous
}
```

**Why AI required:**
- Is `wp_verify_nonce()` return value actually checked?
- Is the action gated by the nonce, or does code continue regardless?
- Are there early-exit patterns that make this safe?

**Scanner's role:** Flag nonce-related patterns.
**AI's role:** Verify the nonce check actually gates the sensitive operation.

---

- [ ] ### 4. Database queries with dynamic table names

```php
// FLAGGED - Needs context
$table = $wpdb->prefix . $user_table_name;
$wpdb->query("SELECT * FROM $table");  // ← Injection if $user_table_name is user input
```

**Why AI required:**
- Where does `$user_table_name` come from?
- Is it from a whitelist or user input?
- Does `$wpdb->prefix` provide any protection? (No, but people think it does)

**Scanner's role:** Flag dynamic table name construction.
**AI's role:** Trace the source of the variable.

---

### 5. Capability checks present but wrong capability

```php
// FLAGGED - Needs context
if (current_user_can('edit_posts')) {  // ← Check exists
    delete_user($user_id);  // ← But wrong capability for action
}
```

**Why AI required:**
- Does the capability match the action's risk level?
- Should this be `delete_users` instead of `edit_posts`?
- Is this intentional (e.g., custom role system)?

**Scanner's role:** Flag capability checks near sensitive operations.
**AI's role:** Evaluate if the capability is appropriate for the action.

---

### 6. HTTP requests without timeout in production paths

```php
// FLAGGED - Needs context
$response = wp_remote_get($url);  // ← No timeout specified

// vs.

$response = wp_remote_get($url, array('timeout' => 30));  // ← Safe
```

**Why AI required:**
- Is this in a user-facing request or a background cron?
- Is the URL internal (fast) or external (slow/unreliable)?
- Does WordPress's default timeout (5s) suffice for this use case?

**Scanner's role:** Flag `wp_remote_*` without explicit timeout.
**AI's role:** Assess if default timeout is acceptable for the context.

---

### 7. Transients/options with user-derived keys

```php
// FLAGGED - Needs context
$key = 'cache_' . $_GET['product_id'];
set_transient($key, $data, HOUR_IN_SECONDS);  // ← Cache poisoning?
```

**Why AI required:**
- Is `$_GET['product_id']` sanitized before use in key?
- Could an attacker create arbitrary transients?
- Is there a limit on how many transients can be created?

**Scanner's role:** Flag dynamic transient/option keys.
**AI's role:** Trace key construction, assess abuse potential.

---

## Implementation Recommendation

### For Tier 1 (Zero-Tolerance)
- Add PHP patterns to match Node.js coverage (including dynamic include/require, eval/create_function, unserialize, `preg_replace` with `/e`, and `assert` with strings)
- Build should fail on any match
- Baseline exceptions are **strongly discouraged**; if used, they MUST include explicit justification, be reviewed by a human, and still appear as warnings (e.g., "BASELINED CRITICAL ISSUE")
- These are "stop the line" issues

### For Tier 2 (AI-Assisted)
- Scanner flags as "Needs Review"
- AI triage examines context and assigns a confidence score per finding
- Severity MAY be adjusted based on AI confidence (for example, downgrade low-confidence matches by one level)
- Human makes final call on ambiguous cases
- Baseline exceptions are allowed with documented justification

### Policy Statement

> **Tier 1** issues represent code patterns that are almost never legitimate in WordPress. Finding them suggests either malware, a critical vulnerability, or copy-pasted code that doesn't belong. These should block deployment by default; any baseline exceptions must be rare, explicitly justified, and still visible as warnings.
>
> **Tier 2** issues are code patterns that *might* be problems depending on context. The scanner's job is to surface them; the AI's job is to evaluate them; the human's job is to make the final call.

---

## Notes for Discussion

- Should Tier 1 patterns fail CI even if baselined?
- Should Tier 2 patterns have different severity based on AI confidence?
- Are there other patterns that belong in either tier?