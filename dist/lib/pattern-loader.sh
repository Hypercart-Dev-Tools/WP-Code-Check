#!/usr/bin/env bash
#
# Pattern Loader Library
# Version: 1.1.0
#
# Loads pattern definitions from JSON files and makes them available to the scanner
#

# ----------------------------------------------------------------------------
# Registry helpers (Phase 2)
# ----------------------------------------------------------------------------

# Determine whether the canonical pattern registry is available.
# The registry path is provided by check-performance.sh via PATTERN_REGISTRY_FILE
# and is generated by dist/bin/pattern-library-manager.sh.
pattern_registry_available() {
	if [ -n "${PATTERN_REGISTRY_FILE:-}" ] && [ -f "$PATTERN_REGISTRY_FILE" ]; then
		if command -v python3 >/dev/null 2>&1; then
			return 0
		fi
	fi
	return 1
}

# Load detection/mitigation fields for a pattern from PATTERN-LIBRARY.json.
#
# This is a thin adapter on top of the registry so the loader does not need to
# know the on-disk layout of individual pattern JSON files. When the registry
# is unavailable (older workflows, custom callers, or missing python3), this
# function simply returns 1 and callers should fall back to per-pattern JSON
# parsing.
#
# Populates, when present:
#   pattern_search
#   pattern_file_patterns
#   pattern_validator_script
#   pattern_validator_args
#   pattern_mitigation_enabled
#   pattern_mitigation_script
#   pattern_mitigation_args
#   pattern_severity_downgrade
_load_pattern_from_registry() {
	local pattern_id_lookup="$1"

	if ! pattern_registry_available; then
		return 1
	fi

	# Use python3 to keep this in sync with build_detection_and_mitigation_json
	# in dist/bin/pattern-library-manager.sh. We intentionally avoid jq and
	# associative arrays so this remains portable to older shells.
		local registry_kv
		registry_kv=$(python3 "$PATTERN_REGISTRY_FILE" "$pattern_id_lookup" 2>/dev/null <<'EOFPY'
import json
import sys

if len(sys.argv) < 3:
    sys.exit(1)

registry_path, target_id = sys.argv[1], sys.argv[2]

try:
    with open(registry_path, "r") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)

pattern = None
for p in data.get("patterns", []):
    if p.get("id") == target_id:
        pattern = p
        break

if not pattern:
    # Not found in registry; let caller fall back to JSON file.
    sys.exit(1)

def emit(key, value):
    if value is None:
        return
    # Normalise to simple shell-friendly representations.
    if isinstance(value, bool):
        sys.stdout.write(f"{key}={'true' if value else 'false'}\n")
    elif isinstance(value, (int, float)):
        sys.stdout.write(f"{key}={value}\n")
    elif isinstance(value, list):
        # Space-separated list for easy iteration in bash.
        sys.stdout.write(f"{key}=" + " ".join(str(v) for v in value) + "\n")
    elif isinstance(value, dict) and key == "severity_downgrade":
        # KEY=VALUE;KEY=VALUE form as expected by check-performance.sh
        parts = [f"{k}={v}" for k, v in value.items()]
        sys.stdout.write(f"{key}=" + ";".join(parts) + "\n")
    else:
        sys.stdout.write(f"{key}={str(value)}\n")

# Base detection fields from registry (already normalised by manager).
if "search_pattern" in pattern:
    emit("search_pattern", pattern.get("search_pattern"))
if "file_patterns" in pattern:
    emit("file_patterns", pattern.get("file_patterns"))
if "validator_script" in pattern:
    emit("validator_script", pattern.get("validator_script"))
if "validator_args" in pattern:
    emit("validator_args", pattern.get("validator_args"))

# Mitigation details are provided by pattern-library-manager as a
# "mitigation_details" object when present.
mitigation = pattern.get("mitigation_details") or {}
if mitigation:
    emit("mitigation_enabled", mitigation.get("enabled", False))
    emit("mitigation_script", mitigation.get("script") or "")
    emit("mitigation_args", mitigation.get("args") or [])
    emit("severity_downgrade", mitigation.get("severity_downgrade") or {})
EOFPY
)

	if [ -z "$registry_kv" ]; then
		# Either not found in registry or lookup failed; fall back to JSON file.
		return 1
	fi

	# Apply registry values to the current pattern globals. We intentionally do
	# not override pattern_detection_type here so that clone_detection and other
	# special cases continue to be driven by the JSON definition.
	while IFS='=' read -r key value; do
		case "$key" in
			search_pattern)
				pattern_search="$value"
				;;
			file_patterns)
				pattern_file_patterns="$value"
				;;
			validator_script)
				pattern_validator_script="$value"
				;;
			validator_args)
				pattern_validator_args="$value"
				;;
			mitigation_enabled)
				pattern_mitigation_enabled="$value"
				;;
			mitigation_script)
				pattern_mitigation_script="$value"
				;;
			mitigation_args)
				pattern_mitigation_args="$value"
				;;
			severity_downgrade)
				pattern_severity_downgrade="$value"
				;;
		esac
	done <<EOF
$registry_kv
EOF

	return 0
}

# Load a single pattern from JSON file
# Usage: load_pattern "path/to/pattern.json"
# Returns: Sets global variables with pattern_ prefix
load_pattern() {
  local pattern_file="$1"
  
  if [ ! -f "$pattern_file" ]; then
    echo "ERROR: Pattern file not found: $pattern_file" >&2
    return 1
  fi

	# Reset globals to avoid any cross-pattern leakage when load_pattern is
	# called repeatedly in a loop.
	pattern_id=""
	pattern_enabled=""
	pattern_detection_type=""
	pattern_category=""
	pattern_severity=""
	pattern_title=""
	pattern_search=""
	pattern_file_patterns=""
	pattern_validator_script=""
	pattern_validator_args=""
	pattern_mitigation_enabled=""
	pattern_mitigation_script=""
	pattern_mitigation_args=""
	pattern_severity_downgrade=""
  
  # Extract key fields using grep/sed (no jq dependency)
  # This is a simple parser - only handles basic JSON structure

  pattern_id=$(grep '"id"' "$pattern_file" | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')

  # Try new format first (detection.type), then fall back to old format (detection_type at root)
  pattern_detection_type=$(grep -A2 '"detection"' "$pattern_file" | grep '"type"' | head -1 | sed 's/.*"type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  if [ -z "$pattern_detection_type" ]; then
    pattern_detection_type=$(grep '"detection_type"' "$pattern_file" | head -1 | sed 's/.*"detection_type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  fi

  pattern_category=$(grep '"category"' "$pattern_file" | head -1 | sed 's/.*"category"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_severity=$(grep '"severity"' "$pattern_file" | head -1 | sed 's/.*"severity"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_title=$(grep '"title"' "$pattern_file" | head -1 | sed 's/.*"title"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

	# If the canonical registry is available, prefer it for detection and
	# mitigation wiring. This keeps scanner behaviour in sync across all
	# pattern consumers.
	_load_pattern_from_registry "$pattern_id" || true

	# Extract search patterns using Python for reliable JSON parsing.
	# Supports:
	# - detection.search_pattern (single pattern, legacy format)
	# - detection.patterns[]."pattern" (new format)
	# - detection.patterns[]."search" (backward-compatible alias used by some rules)
	#
	# When the registry has already provided pattern_search (or for
	# clone_detection, which synthesises its own search strings), we skip
	# per-file extraction.
	if [ -z "$pattern_search" ] && [ "$pattern_detection_type" != "clone_detection" ]; then
	  if command -v python3 &> /dev/null; then
	    pattern_search=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	import sys
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        detection = data.get('detection', {})

	        # 1) Single search_pattern field (legacy/simple rules)
	        if 'search_pattern' in detection:
	            print(detection['search_pattern'])
	        # 2) patterns array (multi-pattern rules)
	        elif 'patterns' in detection and isinstance(detection['patterns'], list):
	            patterns = []
	            for p in detection['patterns']:
	                # Prefer explicit "pattern" key, fall back to "search" for
	                # older/simple definitions like file-get-contents-url.json
	                val = p.get('pattern') or p.get('search')
	                if val:
	                    patterns.append(val)

	            if patterns:
	                # Join patterns with | for grep -E
	                print('|'.join(patterns))
	            else:
	                sys.stderr.write('No usable patterns (pattern/search) found in patterns[]\\n')
	                sys.exit(1)
	        else:
	            sys.stderr.write('No search_pattern or patterns[] found in detection\\n')
	            sys.exit(1)
	except Exception as e:
	    sys.stderr.write(str(e) + '\\n')
	    sys.exit(1)
	EOFPYTHON
		)
	  elif command -v python &> /dev/null; then
	    pattern_search=$(python <<EOFPYTHON 2>/dev/null
	import json
	import sys
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        detection = data.get('detection', {})

	        if 'search_pattern' in detection:
	            print detection['search_pattern']
	        elif 'patterns' in detection and isinstance(detection['patterns'], list):
	            patterns = []
	            for p in detection['patterns']:
	                val = p.get('pattern') or p.get('search')
	                if val:
	                    patterns.append(val)

	            if patterns:
	                print '|'.join(patterns)
	            else:
	                print >> sys.stderr, 'No usable patterns (pattern/search) found in patterns[]'
	                sys.exit(1)
	        else:
	            print >> sys.stderr, 'No search_pattern or patterns[] found in detection'
	            sys.exit(1)
	except Exception as e:
	    print >> sys.stderr, str(e)
	    sys.exit(1)
	EOFPYTHON
		)
	  else
	    # Fallback to grep/sed (less reliable for complex patterns)
	    pattern_search=$(grep '"search_pattern"' "$pattern_file" | head -1 | cut -d'"' -f4 | sed 's/\\\\/\\/g')
	  fi
	fi

  # Default to "direct" if not specified (backward compatibility)
  if [ -z "$pattern_detection_type" ]; then
    pattern_detection_type="direct"
  fi

	# Extract file_patterns array from JSON (for JavaScript/TypeScript support)
	# Use Python for reliable JSON array parsing. If the registry has already
	# provided file_patterns, we respect that and skip the JSON lookup.
	if [ -z "$pattern_file_patterns" ]; then
	  if command -v python3 &> /dev/null; then
	    pattern_file_patterns=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        file_patterns = data.get('detection', {}).get('file_patterns', [])
	        if file_patterns:
	            print(' '.join(file_patterns))
	        else:
	            print('*.php')  # Default to PHP for backward compatibility
	except Exception:
	    print('*.php')  # Fallback to PHP on error
	EOFPYTHON
	)
	  else
	    # Fallback: default to PHP if Python not available
	    pattern_file_patterns="*.php"
	  fi
	fi

	# Extract validator_script path and validator_args for scripted detection type
	# If the registry has already provided a validator_script, prefer that and
	# avoid re-parsing the JSON.
	if [ "$pattern_detection_type" = "scripted" ]; then
	  if [ -z "$pattern_validator_script" ]; then
	    if command -v python3 &> /dev/null; then
	      pattern_validator_script=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        validator = data.get('detection', {}).get('validator_script', '')
	        print(validator)
	except Exception:
	    print('')
	EOFPYTHON
	)
	      pattern_validator_args=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        args = data.get('detection', {}).get('validator_args', [])
	        # Join array elements with spaces
	        print(' '.join(str(arg) for arg in args))
	except Exception:
	    print('')
	EOFPYTHON
	)
	    else
	      # Fallback to grep/sed
	      pattern_validator_script=$(grep '"validator_script"' "$pattern_file" | head -1 | cut -d'"' -f4)
	      pattern_validator_args=""
	    fi
	  fi
	else
	  pattern_validator_script="${pattern_validator_script:-}"
	  pattern_validator_args="${pattern_validator_args:-}"
	fi

	# Extract mitigation_detection configuration. If the registry has already
	# provided mitigation wiring, we prefer that and avoid reopening the JSON.
	if [ -z "$pattern_mitigation_enabled" ] && [ -z "$pattern_mitigation_script" ] && [ -z "$pattern_severity_downgrade" ]; then
	  if command -v python3 &> /dev/null; then
	    pattern_mitigation_enabled=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        enabled = mitigation.get('enabled', False)
	        print('true' if enabled else 'false')
	except Exception:
	    print('false')
	EOFPYTHON
	)
	    pattern_mitigation_script=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        script = mitigation.get('validator_script', '')
	        print(script)
	except Exception:
	    print('')
	EOFPYTHON
	)
	    pattern_mitigation_args=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        args = mitigation.get('validator_args', [])
	        print(' '.join(str(arg) for arg in args))
	except Exception:
	    print('')
	EOFPYTHON
	)
	    pattern_severity_downgrade=$(python3 <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        downgrade = mitigation.get('severity_downgrade', {})
	        # Output as KEY=VALUE pairs separated by semicolons
	        pairs = [f"{k}={v}" for k, v in downgrade.items()]
	        print(';'.join(pairs))
	except Exception:
	    print('')
	EOFPYTHON
	)
	  else
	    pattern_mitigation_enabled="false"
	    pattern_mitigation_script=""
	    pattern_mitigation_args=""
	    pattern_severity_downgrade=""
	  fi
	fi

  # Export for use in calling script
  export pattern_id pattern_enabled pattern_detection_type pattern_category pattern_severity pattern_title pattern_search pattern_file_patterns pattern_validator_script pattern_validator_args pattern_mitigation_enabled pattern_mitigation_script pattern_mitigation_args pattern_severity_downgrade

  return 0
}

# List all available patterns
# Usage: list_patterns "dist/patterns/"
list_patterns() {
  local patterns_dir="$1"
  
  if [ ! -d "$patterns_dir" ]; then
    echo "ERROR: Patterns directory not found: $patterns_dir" >&2
    return 1
  fi
  
  find "$patterns_dir" -name "*.json" -type f | sort
}

# Check if pattern is enabled
# Usage: is_pattern_enabled "path/to/pattern.json"
is_pattern_enabled() {
  local pattern_file="$1"
  local enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')
  
  if [ "$enabled" = "true" ]; then
    return 0
  else
    return 1
  fi
}

# Get pattern metadata as key=value pairs
# Usage: get_pattern_metadata "path/to/pattern.json"
get_pattern_metadata() {
  local pattern_file="$1"
  local detection_type=$(grep '"detection_type"' "$pattern_file" | head -1 | sed 's/.*"detection_type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

  # Default to "direct" if not specified
  if [ -z "$detection_type" ]; then
    detection_type="direct"
  fi

  echo "id=$(grep '"id"' "$pattern_file" | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')"
  echo "detection_type=$detection_type"
  echo "category=$(grep '"category"' "$pattern_file" | head -1 | sed 's/.*"category"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "severity=$(grep '"severity"' "$pattern_file" | head -1 | sed 's/.*"severity"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "title=$(grep '"title"' "$pattern_file" | head -1 | sed 's/.*"title"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
}

# Example usage (commented out):
# load_pattern "dist/patterns/unsanitized-superglobal-isset-bypass.json"
# echo "Pattern ID: $pattern_id"
# echo "Enabled: $pattern_enabled"
# echo "Severity: $pattern_severity"

