#!/usr/bin/env bash
#
# Pattern Loader Library
# Version: 1.1.0
#
# Loads pattern definitions from JSON files and makes them available to the scanner
#

# ----------------------------------------------------------------------------
# Registry helpers (Phase 2 + minimal Phase 3 in-memory cache)
# ----------------------------------------------------------------------------

# Shared registry state (computed once per scan and reused by callers).
# PATTERN_REGISTRY_STATE values:
#   - fresh       	registry is present, python3 available, and not stale
#   - stale       	at least one dist/patterns/*.json file is newer than the registry
#   - unavailable 	registry missing or python3 not available
#   - error       	unexpected error while checking state
PATTERN_REGISTRY_STATE="${PATTERN_REGISTRY_STATE:-unknown}"
PATTERN_REGISTRY_STALE_REASON="${PATTERN_REGISTRY_STALE_REASON:-}"

# Lightweight metrics for debug reporting.
PATTERN_REGISTRY_HITS=${PATTERN_REGISTRY_HITS:-0}
PATTERN_REGISTRY_MISSES=${PATTERN_REGISTRY_MISSES:-0}

# Compute the current registry state only once per scan.
pattern_registry_check_state() {
	# If we've already checked, don't do extra work.
	if [ "${PATTERN_REGISTRY_STATE:-}" != "unknown" ]; then
		return 0
	fi

	if [ -z "${PATTERN_REGISTRY_FILE:-}" ] || [ ! -f "$PATTERN_REGISTRY_FILE" ]; then
		PATTERN_REGISTRY_STATE="unavailable"
		PATTERN_REGISTRY_STALE_REASON=""
		return 0
	fi

	if ! command -v python3 >/dev/null 2>&1; then
		PATTERN_REGISTRY_STATE="unavailable"
		PATTERN_REGISTRY_STALE_REASON="python3 not available"
		return 0
	fi

	local result
	result=$(PYTHONSTARTUP= PATTERN_REGISTRY_FILE="$PATTERN_REGISTRY_FILE" python3 -S <<'EOFPY' 2>/dev/null
import os
import sys

registry_path = os.environ.get("PATTERN_REGISTRY_FILE")
if not registry_path:
    print("error:no_registry_path")
    sys.exit(0)

try:
    registry_mtime = os.path.getmtime(registry_path)
except OSError:
    print("error:missing_registry")
    sys.exit(0)

root = os.path.dirname(registry_path)
patterns_root = os.path.join(root, "patterns")

if not os.path.isdir(patterns_root):
    # No patterns directory; treat registry as fresh for this check.
    print("fresh")
    sys.exit(0)

for dirpath, dirnames, filenames in os.walk(patterns_root):
    for name in filenames:
        if not name.endswith(".json"):
            continue
        path = os.path.join(dirpath, name)
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            continue
        if mtime > registry_mtime:
            rel = os.path.relpath(path, patterns_root)
            print("stale:" + rel)
            sys.exit(0)

print("fresh")
EOFPY
)

	case "$result" in
		fresh)
			PATTERN_REGISTRY_STATE="fresh"
			PATTERN_REGISTRY_STALE_REASON=""
			;;
		stale:*)
			PATTERN_REGISTRY_STATE="stale"
			PATTERN_REGISTRY_STALE_REASON="${result#stale:}"
			;;
		*)
			PATTERN_REGISTRY_STATE="error"
			PATTERN_REGISTRY_STALE_REASON="$result"
			;;
	esac
}

# Determine whether the canonical pattern registry is available.
# The registry path is provided by check-performance.sh via PATTERN_REGISTRY_FILE
# and is generated by dist/bin/pattern-library-manager.sh.
pattern_registry_available() {
	pattern_registry_check_state
	if [ "$PATTERN_REGISTRY_STATE" = "fresh" ]; then
		return 0
	fi
	return 1
}

# Simple on-disk cache built once per scan from PATTERN-LIBRARY.json.
# This avoids re-opening the registry (or individual pattern JSON files)
# for every pattern, while keeping the loader Bash 3compatible.
PATTERN_REGISTRY_CACHE_FILE=""

# Load detection/mitigation fields for a pattern from PATTERN-LIBRARY.json.
#
# This is a thin adapter on top of the registry so the loader does not need to
# know the on-disk layout of individual pattern JSON files. When the registry
# is unavailable (older workflows, custom callers, or missing python3), this
# function simply returns 1 and callers should fall back to per-pattern JSON
# parsing.
#
# Populates, when present:
#   pattern_search
#   pattern_file_patterns
#   pattern_validator_script
#   pattern_validator_args
#   pattern_mitigation_enabled
#   pattern_mitigation_script
#   pattern_mitigation_args
#   pattern_severity_downgrade
_load_pattern_from_registry() {
	local pattern_id_lookup="$1"

	# If the registry is not in a fresh state, record a miss and let callers
	# fall back to per-pattern JSON parsing.
	if ! pattern_registry_available; then
		PATTERN_REGISTRY_MISSES=$((PATTERN_REGISTRY_MISSES + 1))
		return 1
	fi

	# Materialise a simple cache from PATTERN-LIBRARY.json on first use.
		if [ -z "$PATTERN_REGISTRY_CACHE_FILE" ] || [ ! -f "$PATTERN_REGISTRY_CACHE_FILE" ]; then
		local tmpfile
		tmpfile="$(mktemp "${TMPDIR:-/tmp}/wpcc-pattern-registry.XXXXXX" 2>/dev/null || echo "")"
		if [ -z "$tmpfile" ]; then
			PATTERN_REGISTRY_STATE="error"
			if [ -z "${PATTERN_REGISTRY_STALE_REASON:-}" ]; then
				PATTERN_REGISTRY_STALE_REASON="cache_mktemp_failed"
			fi
			PATTERN_REGISTRY_MISSES=$((PATTERN_REGISTRY_MISSES + 1))
			return 1
		fi

			# Build one line per pattern using a whitespace-safe encoding:
			#   <id> search_pattern=<len>:<value> file_patterns=<len>:pat1,pat2 \
			#        validator_script=<len>:<value> validator_args=<len>:arg1,arg2 \
			#        mitigation_enabled=<len>:true ...
			# Each value is prefixed with its byte length and a colon so that the
			# Bash-side parser can safely recover values that contain spaces.
			if command -v python3 >/dev/null 2>&1; then
				PYTHONSTARTUP= PATTERN_REGISTRY_FILE="$PATTERN_REGISTRY_FILE" python3 -S <<'EOFPY' >"$tmpfile" 2>/dev/null || true
import json
import os
import sys

registry_path = os.environ.get("PATTERN_REGISTRY_FILE")
if not registry_path:
    sys.exit(1)

try:
    with open(registry_path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)

patterns = data.get("patterns", [])
for p in patterns:
    pid = p.get("id")
    if not pid:
        continue

    pieces = [pid]

    def add_kv(key, value, is_list=False, is_dict=False):
        if value is None:
            return
        if is_dict:
            if not isinstance(value, dict):
                return
            joined = ";".join(f"{k}={v}" for k, v in value.items())
            val_str = joined
        elif is_list:
            if not isinstance(value, list):
                value = [value]
            joined = ",".join(str(v) for v in value)
            val_str = joined
        elif isinstance(value, bool):
            val_str = "true" if value else "false"
        else:
            val_str = str(value)
        # Length-prefixed encoding: key=<len>:<value> (len in characters)
        length = len(val_str)
        pieces.append(f"{key}={length}:{val_str}")

    add_kv("search_pattern", p.get("search_pattern"))
    add_kv("file_patterns", p.get("file_patterns"), is_list=True)
    add_kv("validator_script", p.get("validator_script"))
    add_kv("validator_args", p.get("validator_args"), is_list=True)

    mitigation = p.get("mitigation_details") or {}
    if isinstance(mitigation, dict) and mitigation:
        add_kv("mitigation_enabled", mitigation.get("enabled", False))
        add_kv("mitigation_script", mitigation.get("script") or "")
        add_kv("mitigation_args", mitigation.get("args") or [], is_list=True)
        add_kv("severity_downgrade", mitigation.get("severity_downgrade") or {}, is_dict=True)

    if len(pieces) > 1:
        sys.stdout.write(" ".join(pieces) + "\n")
EOFPY
		else
			# Without python3 we cannot build the cache; mark registry as error.
			PATTERN_REGISTRY_STATE="error"
			if [ -z "${PATTERN_REGISTRY_STALE_REASON:-}" ]; then
				PATTERN_REGISTRY_STALE_REASON="python3_missing"
			fi
			rm -f "$tmpfile" 2>/dev/null || true
			PATTERN_REGISTRY_MISSES=$((PATTERN_REGISTRY_MISSES + 1))
			return 1
		fi

		# If the cache build produced no output, discard it and fall back to
		# legacy JSON parsing. Treat this as a registry error so callers (and
		# debug reporting) can see that the registry path was unavailable.
		if [ ! -s "$tmpfile" ]; then
			rm -f "$tmpfile" 2>/dev/null || true
			PATTERN_REGISTRY_STATE="error"
			if [ -z "${PATTERN_REGISTRY_STALE_REASON:-}" ]; then
				PATTERN_REGISTRY_STALE_REASON="cache_build_failed"
			fi
			PATTERN_REGISTRY_MISSES=$((PATTERN_REGISTRY_MISSES + 1))
			return 1
		fi

		PATTERN_REGISTRY_CACHE_FILE="$tmpfile"
	fi

		# Lookup entry for this pattern id in the cache file.
		local line
		line=$(grep -E "^${pattern_id_lookup}( |$)" "$PATTERN_REGISTRY_CACHE_FILE" 2>/dev/null | head -n 1 || true)
		if [ -z "$line" ]; then
			# Not found in registry; let caller fall back to JSON file.
			PATTERN_REGISTRY_MISSES=$((PATTERN_REGISTRY_MISSES + 1))
			return 1
		fi

		# Strip leading pattern id and trim leading whitespace.
		line="${line#"$pattern_id_lookup"}"
		line="${line#"${line%%[![:space:]]*}"}"

		# New whitespace-safe parser: each value is encoded as key=<len>:<value>.
		# This allows arbitrary spaces inside values without relying on word-splitting.
		local rest key value len
		rest="$line"
		while [ -n "$rest" ]; do
			# Trim leading whitespace before each token.
			rest="${rest#"${rest%%[![:space:]]*}"}"
			[ -z "$rest" ] && break

			# Extract the key (up to '=')
			key=${rest%%=*}
			# If there was no '=' then we're done.
			if [ "$key" = "$rest" ]; then
				break
			fi
			# Drop 'key=' from the front.
			rest=${rest#"$key="}

			# Expect a length prefix of the form '<len>:'
			len=${rest%%:*}
			# If there is no ':' delimiter, abort parsing this line.
			if [ "$len" = "$rest" ]; then
				break
			fi
			# Drop '<len>:' from the front.
			rest=${rest#"$len:"}

			# Extract exactly <len> bytes as the value; the remainder stays in $rest.
			value=${rest%%${rest#?}}
			if [ "$len" -gt 0 ]; then
				value=${rest%%${rest#?}}
				# Use POSIX parameter expansion to grab the first $len characters.
				value=$(printf '%s' "$rest" | cut -c1-$len)
				# Advance rest past the consumed value.
				rest=${rest#"$value"}
			else
				value=""
			fi

			case "$key" in
				search_pattern)
					pattern_search="$value"
					;;
				file_patterns)
					# Convert comma-separated list back to space-separated for callers.
					pattern_file_patterns="${value//,/ }"
					;;
				validator_script)
					pattern_validator_script="$value"
					;;
				validator_args)
					pattern_validator_args="${value//,/ }"
					;;
				mitigation_enabled)
					pattern_mitigation_enabled="$value"
					;;
				mitigation_script)
					pattern_mitigation_script="$value"
					;;
				mitigation_args)
					pattern_mitigation_args="${value//,/ }"
					;;
				severity_downgrade)
					pattern_severity_downgrade="$value"
					;;
			esac
		done

	PATTERN_REGISTRY_HITS=$((PATTERN_REGISTRY_HITS + 1))
	return 0
}

# Load a single pattern from JSON file
# Usage: load_pattern "path/to/pattern.json"
# Returns: Sets global variables with pattern_ prefix
load_pattern() {
  local pattern_file="$1"
  
  if [ ! -f "$pattern_file" ]; then
    echo "ERROR: Pattern file not found: $pattern_file" >&2
    return 1
  fi

	# Reset globals to avoid any cross-pattern leakage when load_pattern is
	# called repeatedly in a loop.
	pattern_id=""
	pattern_enabled=""
	pattern_detection_type=""
	pattern_category=""
	pattern_severity=""
	pattern_title=""
	pattern_search=""
	pattern_file_patterns=""
	pattern_validator_script=""
	pattern_validator_args=""
	pattern_mitigation_enabled=""
	pattern_mitigation_script=""
	pattern_mitigation_args=""
	pattern_severity_downgrade=""
  
  # Extract key fields using grep/sed (no jq dependency)
  # This is a simple parser - only handles basic JSON structure

  pattern_id=$(grep '"id"' "$pattern_file" | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')

  # Try new format first (detection.type), then fall back to old format (detection_type at root)
  pattern_detection_type=$(grep -A2 '"detection"' "$pattern_file" | grep '"type"' | head -1 | sed 's/.*"type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  if [ -z "$pattern_detection_type" ]; then
    pattern_detection_type=$(grep '"detection_type"' "$pattern_file" | head -1 | sed 's/.*"detection_type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  fi

  pattern_category=$(grep '"category"' "$pattern_file" | head -1 | sed 's/.*"category"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_severity=$(grep '"severity"' "$pattern_file" | head -1 | sed 's/.*"severity"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  pattern_title=$(grep '"title"' "$pattern_file" | head -1 | sed 's/.*"title"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

	# If the canonical registry is available, prefer it for detection and
	# mitigation wiring. This keeps scanner behaviour in sync across all
	# pattern consumers.
	_load_pattern_from_registry "$pattern_id" || true

	# Extract search patterns using Python for reliable JSON parsing.
	# Supports:
	# - detection.search_pattern (single pattern, legacy format)
	# - detection.patterns[]."pattern" (new format)
	# - detection.patterns[]."search" (backward-compatible alias used by some rules)
	#
	# When the registry has already provided pattern_search (or for
	# clone_detection, which synthesises its own search strings), we skip
	# per-file extraction.
		if [ -z "$pattern_search" ] && [ "$pattern_detection_type" != "clone_detection" ]; then
		  if command -v python3 &> /dev/null; then
		    pattern_search=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	import sys
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        detection = data.get('detection', {})

	        # 1) Single search_pattern field (legacy/simple rules)
	        if 'search_pattern' in detection:
	            print(detection['search_pattern'])
	        # 2) patterns array (multi-pattern rules)
	        elif 'patterns' in detection and isinstance(detection['patterns'], list):
	            patterns = []
	            for p in detection['patterns']:
	                # Prefer explicit "pattern" key, fall back to "search" for
	                # older/simple definitions like file-get-contents-url.json
	                val = p.get('pattern') or p.get('search')
	                if val:
	                    patterns.append(val)

	            if patterns:
	                # Join patterns with | for grep -E
	                print('|'.join(patterns))
	            else:
	                sys.stderr.write('No usable patterns (pattern/search) found in patterns[]\\n')
	                sys.exit(1)
	        else:
	            sys.stderr.write('No search_pattern or patterns[] found in detection\\n')
	            sys.exit(1)
	except Exception as e:
	    sys.stderr.write(str(e) + '\\n')
	    sys.exit(1)
	EOFPYTHON
		)
		  elif command -v python &> /dev/null; then
		    pattern_search=$(PYTHONSTARTUP= python <<EOFPYTHON 2>/dev/null
	import json
	import sys
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        detection = data.get('detection', {})

	        if 'search_pattern' in detection:
	            print detection['search_pattern']
	        elif 'patterns' in detection and isinstance(detection['patterns'], list):
	            patterns = []
	            for p in detection['patterns']:
	                val = p.get('pattern') or p.get('search')
	                if val:
	                    patterns.append(val)

	            if patterns:
	                print '|'.join(patterns)
	            else:
	                print >> sys.stderr, 'No usable patterns (pattern/search) found in patterns[]'
	                sys.exit(1)
	        else:
	            print >> sys.stderr, 'No search_pattern or patterns[] found in detection'
	            sys.exit(1)
	except Exception as e:
	    print >> sys.stderr, str(e)
	    sys.exit(1)
	EOFPYTHON
		)
	  else
	    # Fallback to grep/sed (less reliable for complex patterns)
	    pattern_search=$(grep '"search_pattern"' "$pattern_file" | head -1 | cut -d'"' -f4 | sed 's/\\\\/\\/g')
	  fi
	fi

  # Default to "direct" if not specified (backward compatibility)
  if [ -z "$pattern_detection_type" ]; then
    pattern_detection_type="direct"
  fi

	# Extract file_patterns array from JSON (for JavaScript/TypeScript support)
	# Use Python for reliable JSON array parsing. If the registry has already
	# provided file_patterns, we respect that and skip the JSON lookup.
		if [ -z "$pattern_file_patterns" ]; then
		  if command -v python3 &> /dev/null; then
		    pattern_file_patterns=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        file_patterns = data.get('detection', {}).get('file_patterns', [])
	        if file_patterns:
	            print(' '.join(file_patterns))
	        else:
	            print('*.php')  # Default to PHP for backward compatibility
	except Exception:
	    print('*.php')  # Fallback to PHP on error
	EOFPYTHON
	)
	  else
	    # Fallback: default to PHP if Python not available
	    pattern_file_patterns="*.php"
	  fi
	fi

	# Extract validator_script path and validator_args for scripted detection type
	# If the registry has already provided a validator_script, prefer that and
	# avoid re-parsing the JSON.
		if [ "$pattern_detection_type" = "scripted" ]; then
		  if [ -z "$pattern_validator_script" ]; then
		    if command -v python3 &> /dev/null; then
		      pattern_validator_script=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        validator = data.get('detection', {}).get('validator_script', '')
	        print(validator)
	except Exception:
	    print('')
	EOFPYTHON
	)
		      pattern_validator_args=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        args = data.get('detection', {}).get('validator_args', [])
	        # Join array elements with spaces
	        print(' '.join(str(arg) for arg in args))
	except Exception:
	    print('')
	EOFPYTHON
	)
	    else
	      # Fallback to grep/sed
	      pattern_validator_script=$(grep '"validator_script"' "$pattern_file" | head -1 | cut -d'"' -f4)
	      pattern_validator_args=""
	    fi
	  fi
	else
	  pattern_validator_script="${pattern_validator_script:-}"
	  pattern_validator_args="${pattern_validator_args:-}"
	fi

	# Extract mitigation_detection configuration. If the registry has already
	# provided mitigation wiring, we prefer that and avoid reopening the JSON.
		if [ -z "$pattern_mitigation_enabled" ] && [ -z "$pattern_mitigation_script" ] && [ -z "$pattern_severity_downgrade" ]; then
		  if command -v python3 &> /dev/null; then
		    pattern_mitigation_enabled=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        enabled = mitigation.get('enabled', False)
	        print('true' if enabled else 'false')
	except Exception:
	    print('false')
	EOFPYTHON
	)
		    pattern_mitigation_script=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        script = mitigation.get('validator_script', '')
	        print(script)
	except Exception:
	    print('')
	EOFPYTHON
	)
		    pattern_mitigation_args=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        args = mitigation.get('validator_args', [])
	        print(' '.join(str(arg) for arg in args))
	except Exception:
	    print('')
	EOFPYTHON
	)
		    pattern_severity_downgrade=$(PYTHONSTARTUP= python3 -S <<EOFPYTHON 2>/dev/null
	import json
	try:
	    with open('$pattern_file', 'r') as f:
	        data = json.load(f)
	        mitigation = data.get('mitigation_detection', {})
	        downgrade = mitigation.get('severity_downgrade', {})
	        # Output as KEY=VALUE pairs separated by semicolons
	        pairs = [f"{k}={v}" for k, v in downgrade.items()]
	        print(';'.join(pairs))
	except Exception:
	    print('')
	EOFPYTHON
	)
	  else
	    pattern_mitigation_enabled="false"
	    pattern_mitigation_script=""
	    pattern_mitigation_args=""
	    pattern_severity_downgrade=""
	  fi
	fi

  # Export for use in calling script
  export pattern_id pattern_enabled pattern_detection_type pattern_category pattern_severity pattern_title pattern_search pattern_file_patterns pattern_validator_script pattern_validator_args pattern_mitigation_enabled pattern_mitigation_script pattern_mitigation_args pattern_severity_downgrade

  return 0
}

# List all available patterns
# Usage: list_patterns "dist/patterns/"
list_patterns() {
  local patterns_dir="$1"
  
  if [ ! -d "$patterns_dir" ]; then
    echo "ERROR: Patterns directory not found: $patterns_dir" >&2
    return 1
  fi
  
  find "$patterns_dir" -name "*.json" -type f | sort
}

# Check if pattern is enabled
# Usage: is_pattern_enabled "path/to/pattern.json"
is_pattern_enabled() {
  local pattern_file="$1"
  local enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')
  
  if [ "$enabled" = "true" ]; then
    return 0
  else
    return 1
  fi
}

# Get pattern metadata as key=value pairs
# Usage: get_pattern_metadata "path/to/pattern.json"
get_pattern_metadata() {
  local pattern_file="$1"
  local detection_type=$(grep '"detection_type"' "$pattern_file" | head -1 | sed 's/.*"detection_type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

  # Default to "direct" if not specified
  if [ -z "$detection_type" ]; then
    detection_type="direct"
  fi

  echo "id=$(grep '"id"' "$pattern_file" | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "enabled=$(grep '"enabled"' "$pattern_file" | head -1 | sed 's/.*"enabled"[[:space:]]*:[[:space:]]*\([^,]*\).*/\1/' | tr -d ' ')"
  echo "detection_type=$detection_type"
  echo "category=$(grep '"category"' "$pattern_file" | head -1 | sed 's/.*"category"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "severity=$(grep '"severity"' "$pattern_file" | head -1 | sed 's/.*"severity"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  echo "title=$(grep '"title"' "$pattern_file" | head -1 | sed 's/.*"title"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
}

# Example usage (commented out):
# load_pattern "dist/patterns/unsanitized-superglobal-isset-bypass.json"
# echo "Pattern ID: $pattern_id"
# echo "Enabled: $pattern_enabled"
# echo "Severity: $pattern_severity"

